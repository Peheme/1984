document.addEventListener('DOMContentLoaded', () => {
    // --- SUPABASE CONFIGURATION ---
    const SUPABASE_URL = 'https://npkzsyowqucmqxbgsdfl.supabase.co';
    const SUPABASE_KEY = 'sb_publishable_UEIKkuM1xJTx24VIgssaxw_lQLpl04t';

    // Check if configuration is missing (Double check to be safe)
    if (SUPABASE_URL === 'YOUR_SUPABASE_URL' || SUPABASE_KEY === 'YOUR_SUPABASE_ANON_KEY') {
        console.warn('Supabase not configured.');
        alert("Veuillez configurer l'URL et la Cl√© Supabase dans script.js !");
    }

    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

    const postInput = document.getElementById('post-input');
    const postBtn = document.getElementById('post-btn');
    const feed = document.getElementById('feed');
    const favoritesFeed = document.getElementById('favorites-feed');
    const favoritesSection = document.getElementById('favorites-section');
    const emojiBtn = document.getElementById('emoji-btn');
    const emojiPicker = document.getElementById('emoji-picker');
    const emojiOptions = document.querySelectorAll('.emoji-option');
    const historyList = document.getElementById('history-list');

    let currentFilter = 'all'; // 'all' or 'YYYY-MM'

    // Load posts from Supabase on startup
    fetchPosts();

    // Auto-resize textarea
    postInput.addEventListener('input', function () {
        this.style.height = 'auto';
        this.style.height = (this.scrollHeight) + 'px';
        updatePostButton();
    });

    // Handle Enter to submit (Shift+Enter for newline)
    postInput.addEventListener('keydown', function (e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            createPost();
        }
    });

    // Handle post submission
    postBtn.addEventListener('click', createPost);

    // Toggle Emoji Picker
    emojiBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        emojiPicker.classList.toggle('hidden');
    });

    // Close picker when clicking outside & close share menus
    document.addEventListener('click', (e) => {
        if (!emojiPicker.contains(e.target) && e.target !== emojiBtn) {
            emojiPicker.classList.add('hidden');
        }

        document.querySelectorAll('.share-menu').forEach(menu => {
            if (!menu.classList.contains('hidden')) {
                menu.classList.add('hidden');
            }
        });
    });

    // Add emoji to textarea
    emojiOptions.forEach(emoji => {
        emoji.addEventListener('click', () => {
            const cursorPosition = postInput.selectionStart;
            const text = postInput.value;
            const newText = text.slice(0, cursorPosition) + emoji.textContent + text.slice(cursorPosition);
            postInput.value = newText;
            postInput.focus();
            postInput.setSelectionRange(cursorPosition + emoji.textContent.length, cursorPosition + emoji.textContent.length);
            emojiPicker.classList.add('hidden');
            updatePostButton();
        });
    });

    function updatePostButton() {
        if (postInput.value.trim().length > 0) {
            postBtn.removeAttribute('disabled');
        } else {
            postBtn.setAttribute('disabled', 'true');
        }
    }

    // Initialize button state
    updatePostButton();

    async function createPost() {
        const content = postInput.value.trim();
        if (!content) return;

        // Insert into Supabase
        const { data, error } = await supabase
            .from('posts')
            .insert([
                {
                    content: content,
                    author: 'Pierre-Marie',
                    favorites: false
                    // created_at is auto-generated by DB
                }
            ])
            .select();

        if (error) {
            console.error('Error creating post:', error);
            alert('Erreur lors de la publication du message.');
            return;
        }

        if (data && data.length > 0) {
            const newPost = data[0];
            renderPost(newPost, true); // true = prepend (newest)

            // Reset input
            postInput.value = '';
            postInput.style.height = 'auto';
            updatePostButton();
        }
    }

    async function fetchPosts() {
        // Fetch all posts, ordered by creation date (newest first)
        const { data, error } = await supabase
            .from('posts')
            .select('*')
            .order('created_at', { ascending: true }); // We render by prepending, so we want OLDEST first to end up with NEWEST on top?
        // Actually:
        // If we use prepend() in renderPost, the last item processed ends up at the TOP.
        // So if we process 1, then 2, then 3. 
        // Feed: [3] [2] [1]
        // So we want to process Oldest -> Newest (Ascending).
        // So default sort ASC is correct.

        if (error) {
            console.error('Error fetching posts:', error);
            return;
        }

        // Clear feed before rendering? Or assume empty on load.
        feed.innerHTML = '';
        favoritesFeed.innerHTML = '';
        historyList.innerHTML = '<li class="history-item active" data-date="all">Tous les messages</li>';
        historyMap.clear();

        if (data) {
            data.forEach(post => {
                renderPost(post, true); // prepend
            });
        }
    }

    // We used to have renderPost prepend.
    function renderPost(post, prepend = true) {
        const postElement = document.createElement('div');
        postElement.className = 'post';
        postElement.dataset.id = post.id;

        const date = new Date(post.created_at);
        const timeString = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const dateString = date.toLocaleDateString([], { day: 'numeric', month: 'short' });

        const monthKey = date.toLocaleString('default', { month: 'long' }) + ' ' + date.getFullYear();
        const filterKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

        postElement.dataset.date = filterKey;

        postElement.innerHTML = `
            <div class="post-header">
                <div class="avatar">üë§</div>
                <div class="post-meta">
                    <span class="author-name">${escapeHtml(post.author || 'Inconnu')}</span>
                    <span class="post-time">${dateString} √† ${timeString}</span>
                </div>
            </div>
            <div class="post-content">${escapeHtml(post.content)}</div>
            <div class="post-actions">
                <button class="action-btn favorite ${post.favorites ? 'active' : ''}" onclick="toggleFavorite(${post.id}, this)">
                    <span>${post.favorites ? 'üåü' : '‚≠ê'}</span> ${post.favorites ? 'Retirer des favoris' : 'Favori'}
                </button>
                <div style="position: relative;">
                    <button class="action-btn share" onclick="toggleShareMenu(event, this)">
                        <span>üîó</span> Partager
                    </button>
                    <div class="share-menu hidden">
                        <a href="https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(window.location.href)}" target="_blank" class="share-option">Facebook</a>
                        <a href="https://twitter.com/intent/tweet?text=${encodeURIComponent(post.content)}" target="_blank" class="share-option">Twitter</a>
                        <a href="https://wa.me/?text=${encodeURIComponent(post.content)}" target="_blank" class="share-option">WhatsApp</a>
                    </div>
                </div>
                <!-- Admin only delete button -->
                <button class="action-btn delete" onclick="deletePost(${post.id}, this)">
                    <span>üóëÔ∏è</span> Supprimer
                </button>
            </div>
        `;

        // Handle where to insert
        const feeContainer = post.favorites ? favoritesFeed : feed;

        if (prepend) {
            feeContainer.prepend(postElement);
        } else {
            feeContainer.appendChild(postElement);
        }

        if (post.favorites) {
            favoritesSection.classList.remove('hidden');
        }

        updateHistory(filterKey, monthKey);

        // Apply current filter
        if (currentFilter !== 'all' && currentFilter !== filterKey) {
            postElement.style.display = 'none';
        }
    }

    // Making functions global and async where needed
    window.deletePost = async function (id, btn) {
        if (confirm("Voulez-vous vraiment supprimer ce post ?")) {
            const { error } = await supabase
                .from('posts')
                .delete()
                .eq('id', id);

            if (error) {
                console.error('Error deleting post:', error);
                alert('Erreur lors de la suppression.');
                return;
            }

            const post = btn.closest('.post');
            post.remove();
            checkFavoritesEmpty();
        }
    };

    window.toggleFavorite = async function (id, btn) {
        const post = btn.closest('.post');
        const isFavorite = !btn.classList.contains('active'); // Toggling to NEW state

        const { error } = await supabase
            .from('posts')
            .update({ favorites: isFavorite })
            .eq('id', id);

        if (error) {
            console.error('Error updating favorite:', error);
            alert('Erreur lors de la mise √† jour.');
            return;
        }

        // Update UI
        btn.classList.toggle('active');
        if (isFavorite) {
            btn.innerHTML = '<span>üåü</span> Retirer des favoris';
            favoritesFeed.prepend(post);
            favoritesSection.classList.remove('hidden');
        } else {
            btn.innerHTML = '<span>‚≠ê</span> Favori';
            feed.prepend(post);
            checkFavoritesEmpty();
        }
    };

    window.toggleShareMenu = function (e, btn) {
        e.stopPropagation();
        document.querySelectorAll('.share-menu').forEach(menu => menu.classList.add('hidden'));

        const menu = btn.nextElementSibling;
        menu.classList.toggle('hidden');
    };

    function checkFavoritesEmpty() {
        if (favoritesFeed.children.length === 0) {
            favoritesSection.classList.add('hidden');
        }
    }

    // History Sidebar Logic
    const historyMap = new Set();

    function updateHistory(filterKey, displayString) {
        if (!historyMap.has(filterKey)) {
            historyMap.add(filterKey);

            const existingItem = document.querySelector(`.history-item[data-date="${filterKey}"]`);
            if (!existingItem) {
                const li = document.createElement('li');
                li.className = 'history-item';
                li.dataset.date = filterKey;
                li.textContent = displayString.charAt(0).toUpperCase() + displayString.slice(1);

                li.addEventListener('click', () => filterPosts(filterKey, li));

                historyList.appendChild(li);
            }
        }
    }

    document.querySelector('.history-item[data-date="all"]').addEventListener('click', function () {
        filterPosts('all', this);
    });

    function filterPosts(key, clickedItem) {
        currentFilter = key;

        document.querySelectorAll('.history-item').forEach(item => item.classList.remove('active'));
        clickedItem.classList.add('active');

        const posts = document.querySelectorAll('.post');
        posts.forEach(post => {
            if (key === 'all' || post.dataset.date === key) {
                post.style.display = 'block';
            } else {
                post.style.display = 'none';
            }
        });
    }

    function escapeHtml(text) {
        if (!text) return '';
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, function (m) { return map[m]; });
    }
});
